<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>marketools.simulator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>marketools.simulator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import warnings
import pandas as pd
from marketools.wallet import calculate_investment_value, Wallet
from marketools.extra_print import print_green, print_red, \
    determine_print_color_from_prices, info_str


class Simulator:
    &#34;&#34;&#34;
    Simulator for stock market strategies.

    Attributes
    ----------
    time_range : pandas.DatetimeIndex
        an array with trading days only (no Saturdays, Sundays, holidays)
    traded_stocks_data : dict
        a dictionary with stocks.stock.Stock instances
    wallet : marketools.Wallet
        Wallet for trading
    max_positions : int
        maximum number of different stocks in the wallet
    take_profit : float
        if the price of a stock increases by this fraction, it will be sold;
        if equal 0 - take profit is deactivated (default)
    stop_loss : float
        if the price of a stock decreases by this fraction (comparing to the
        purchase price), it will be sold;
        if equal 0 - stop loss is deactivated (default)
    live_trading : boolean
        if True selling immediately when stop loss / take profit is reached is
        simulated
    &#34;&#34;&#34;

    def __init__(self, time_range: pd.DatetimeIndex, traded_stocks_data: dict,
                 wallet: Wallet, max_positions: int = 5,
                 take_profit: float = 0.0, stop_loss: float = 0.0,
                 live_trading: bool = False):

        self.time_range = time_range
        self.traded_stocks_data = traded_stocks_data
        self.wallet = wallet
        self.wallet_init_value = wallet.total_value
        self.max_positions = max_positions
        self.take_profit = take_profit
        self.stop_loss = stop_loss
        self.live_trading = live_trading
        self.wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Resets the value of wallet to initial value, and removes all stocks from
        the wallet and its history.
        &#34;&#34;&#34;
        self.wallet = Wallet(self.wallet.rate, self.wallet.minimum)
        self.wallet.money = self.wallet_init_value
        self.wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])

    def run(self, strategy_function, *args, **kwargs) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Runs the simulation for given strategy and returns DataFrame with
        wallet value for each day in given time range.

        Parameters
        ----------
        strategy_function : func
            Function with investment strategy. Must take dictionary with traded
            stocks data (self.traded_stocks_data) and date as inputs. Must
            return set of lists (stocks_to_buy, stocks_to_sell).
        kwargs
            Other inputs to investment strategy (strategy_function).

        Returns
        -------
        pandas.DataFrame
        &#34;&#34;&#34;

        stocks_to_buy = []
        stocks_to_sell = []

        for day in self.time_range:
            day_str = day.strftime(&#39;%Y-%m-%d&#39;)

            # Buy selected day before. Loop over list, order can be important
            # here. Strategy can sort relevant stocks - high priority first.
            for tck in stocks_to_buy:

                if not self.wallet.get_volume_of_stocks(tck):
                    price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                        .get(day, None)

                    if price:
                        total = calculate_investment_value(
                            self.wallet, self.max_positions)

                        # needs some money to pay commission
                        total = total - self.wallet.commission(total)
                        volume = math.floor(total / price)

                        if volume &gt; 0:
                            self.wallet.buy(tck, volume, price)
                            print(info_str(day_str, &#39;B&#39;, tck, volume, price))
                            # make sure to not sell it the same day

                            if tck in stocks_to_sell:
                                stocks_to_sell.remove(tck)

            # Sell selected day before. List to set, we don&#39;t care here about
            # the order. Set will remove duplicates.
            for tck in set(stocks_to_sell):

                if self.wallet.get_volume_of_stocks(tck):
                    price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                        .get(day, None)

                    if price:
                        print_color = determine_print_color_from_prices(
                            price,
                            self.wallet.get_purchase_price_of_stocks(tck))
                        volume = self.wallet.sell_all(tck, price)
                        print_color(info_str(day_str, &#39;S&#39;, tck, volume, price))

            # call decorated function - strategy function
            stocks_to_buy, stocks_to_sell = strategy_function(
                day=day, traded_stocks=self.traded_stocks_data, *args, **kwargs)

            # if auto trading is active, check if price of any stock in the
            # wallet crossed take profit or stop loss price; if yes then sell it
            # immediately
            if self.live_trading:

                for tck in self.wallet.list_stocks().copy():
                    price_max = self.traded_stocks_data[tck].ohlc[&#39;High&#39;]\
                        .get(day, None)

                    if price_max:
                        self.wallet.update_price(tck, price_max)

                    if self.wallet.change(tck) &gt; self.take_profit:
                        # selling it immediately
                        price = self.wallet.get_purchase_price_of_stocks(tck)\
                                * (1 + self.take_profit)
                        price = round(price, 2)
                        volume = self.wallet.sell_all(tck, price)
                        print_green(info_str(day_str, &#39;TP&#39;, tck, volume, price))
                        continue

                    price_min = self.traded_stocks_data[tck].ohlc[&#39;Low&#39;]\
                        .get(day, None)

                    if price_min:
                        self.wallet.update_price(tck, price_min)

                    if self.wallet.change(tck) &lt; -self.stop_loss:
                        # selling it immediately
                        price = self.wallet.get_purchase_price_of_stocks(tck)\
                                * (1 - self.stop_loss)
                        price = round(price, 2)
                        volume = self.wallet.sell_all(tck, price)
                        print_red(info_str(day_str, &#39;SL&#39;, tck, volume, price))

            for tck in self.wallet.list_stocks():
                # update the price to the closing price
                ohlc = self.traded_stocks_data[tck].ohlc
                price = ohlc[&#39;Close&#39;].get(day, None)

                if price:
                    self.wallet.update_price(tck, price)

                # if auto trading is not active, then take profit / stop loss
                # the next day
                if not self.live_trading:

                    # take profit the next day
                    if (self.take_profit &gt; 0) \
                            and (self.wallet.change(tck) &gt; self.take_profit):
                        stocks_to_sell.append(tck)

                    # stop loss the next day - price below purchase price
                    if (self.stop_loss &gt; 0)\
                            and (self.wallet.change(tck) &lt; -self.stop_loss):
                        stocks_to_sell.append(tck)

            # save history of the wallet
            self.wallet_history = self.wallet_history.append(
                {&#39;Date&#39;: day, &#39;Wallet state&#39;: self.wallet.total_value},
                ignore_index=True)

        return self.wallet_history


def simulator(time_range: pd.DatetimeIndex,
              traded_stocks: dict, 
              wallet: Wallet, 
              max_positions: int = 5, 
              take_profit: float = 0.0, 
              stop_loss: float = 0.0, 
              auto_trading: bool = False):
    &#34;&#34;&#34;
    This function returns decorator for a stock market strategy, that returns 
    change of wallet value over given time_range (in pandas.DataFrame)

    Parameters
    ----------
    time_range : pandas.DatetimeIndex
        an array with trading days only (no Saturdays, Sundays, holidays)
    traded_stocks : dict
        a dictionary with stocks.stock.Stock instances
    wallet : marketools.Wallet
        Wallet for trading 
    max_positions : int 
        maximum number of different stocks in the wallet
    take_profit : float
        if the price of a stock increases by this fraction, it will be sold;
        if equal 0 - take profit is deactivated (default)
    stop_loss : float
        if the price of a stock decreases by this fraction (comparing to the 
        purchase price), it will be sold; 
        if equal 0 - stop loss is deactivated (default)
    auto_trading : boolean
        if True selling immediately when stop loss / take profit is reached is 
        simulated

    Returns
    -------
    decorator that returns pandas.DataFrame
    &#34;&#34;&#34;

    warnings.warn(&#34;deprecated, consider using Simulator class instead&#34;,
                  DeprecationWarning)

    def strategy_wrapper(func):

        def simulation(*args, **kwargs):
            wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])
            stocks_to_buy = []
            stocks_to_sell = []

            for day in time_range:
                day_str = day.strftime(&#39;%Y-%m-%d&#39;)

                # Buy selected day before. Loop over list, order can be important here.
                # Strategy can sort relevant stocks - high priority first.
                for tck in stocks_to_buy:
                    if not wallet.get_volume_of_stocks(tck):
                        price = traded_stocks[tck].ohlc[&#39;Open&#39;].get(day, None)
                        if price:
                            total = calculate_investment_value(wallet, max_positions)
                            total = total - wallet(total)  # needs some money to pay commission
                            volume = math.floor(total/price)
                            if volume &gt; 0:
                                wallet.buy(tck, volume, price)
                                print(info_str(day_str, &#39;B&#39;, tck, volume, price))
                                # make sure to not sell it the same day
                                if tck in stocks_to_sell:
                                    stocks_to_sell.remove(tck)

                # Sell selected day before. List to set, we dont care here about the order.
                # Set will remove duplicates.
                for tck in set(stocks_to_sell):
                    if wallet.get_volume_of_stocks(tck):
                        price = traded_stocks[tck].ohlc[&#39;Open&#39;].get(day, None)
                        if price: 
                            print_color = determine_print_color_from_prices(price, wallet.get_purchase_price_of_stocks(tck))
                            volume = wallet.sell_all(tck, price)
                            print_color(info_str(day_str, &#39;S&#39;, tck, volume, price))

                # call decorated function - strategy function
                stocks_to_buy, stocks_to_sell = func(day=day, traded_stocks=traded_stocks, *args, **kwargs)

                # if auto trading is active, check if price of any stock in the wallet crossed
                # take proffit or stop loss price; if yes then sell it immediately 
                if auto_trading:
                    for tck in wallet.list_stocks().copy():

                        price_max = traded_stocks[tck].ohlc[&#39;High&#39;].get(day, None)
                        if price:
                            wallet.update_price(tck, price_max)
                        if wallet.change(tck) &gt; take_profit:
                            price = wallet.get_purchase_price_of_stocks(tck) * (1+take_profit)  # selling it immediately
                            price = round(price, 2)
                            volume = wallet.sell_all(tck, price)
                            print_green(info_str(day_str, &#39;TP&#39;, tck, volume, price))
                            continue

                        price_min = traded_stocks[tck].ohlc[&#39;Low&#39;].get(day, None)
                        if price:
                            wallet.update_price(tck, price_min)
                        if wallet.change(tck) &lt; -stop_loss:
                            price = wallet.get_purchase_price_of_stocks(tck) * (1-stop_loss)  # selling it immediately
                            price = round(price, 2)
                            volume = wallet.sell_all(tck, price)
                            print_red(info_str(day_str, &#39;SL&#39;, tck, volume, price))
                            
                for tck in wallet.list_stocks():                        
                    # update the price to the closing price and calculate relative price change
                    ohlc = traded_stocks[tck].ohlc
                    price = ohlc[&#39;Close&#39;].get(day, None)
                    if price:
                        wallet.update_price(tck, price)

                    # if auto trading is not active, then take profit / stop loss the next day
                    if not auto_trading:

                        # take profit the next day
                        if take_profit and wallet.change(tck) &gt; take_profit:
                            stocks_to_sell.append(tck)

                        # stop loss the next day - price below purchase price
                        if stop_loss and wallet.change(tck) &lt; -stop_loss:
                            stocks_to_sell.append(tck)

                # save history of the wallet
                wallet_history = wallet_history.append(
                    {&#39;Date&#39;: day, &#39;Wallet state&#39;: wallet.total_value},
                    ignore_index=True
                    )
            
            return wallet_history

        return simulation

    return strategy_wrapper


# if None:
#     &#34;&#34;&#34;
#     This code should not be called - this is just a template function for tested strategy.
#     &#34;&#34;&#34;
#     @simulator(TRADING_DAYS, stocks_data, MY_WALLET, TAKE_PROFIT, STOP_LOSS)
#     def __strategy_template(arguments, *args, **kwargs):
#         &#34;&#34;&#34;
#         :param arguments: any arguments needed for the strategy can be passed
#         &#34;&#34;&#34;
#         day = kwargs[&#39;day&#39;]  # argument passed by decorator
#         traded_stocks = kwargs[&#39;traded_stocks&#39;]  # argument passed by decorator
#         stocks_to_buy = []
#         stocks_to_sell = []
#
#         &#34;&#34;&#34;
#         place for code that will fill in stocks_to_buy and stocks_to_sell sets with tickers
#         &#34;&#34;&#34;
#
#         return stocks_to_buy, stocks_to_sell


if __name__ == &#39;__main__&#39;:
    pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="marketools.simulator.simulator"><code class="name flex">
<span>def <span class="ident">simulator</span></span>(<span>time_range: pandas.core.indexes.datetimes.DatetimeIndex, traded_stocks: dict, wallet: marketools.wallet.Wallet, max_positions: int = 5, take_profit: float = 0.0, stop_loss: float = 0.0, auto_trading: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns decorator for a stock market strategy, that returns
change of wallet value over given time_range (in pandas.DataFrame)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_range</code></strong> :&ensp;<code>pandas.DatetimeIndex</code></dt>
<dd>an array with trading days only (no Saturdays, Sundays, holidays)</dd>
<dt><strong><code>traded_stocks</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary with stocks.stock.Stock instances</dd>
<dt><strong><code>wallet</code></strong> :&ensp;<code>marketools.Wallet</code></dt>
<dd>Wallet for trading</dd>
<dt><strong><code>max_positions</code></strong> :&ensp;<code>int </code></dt>
<dd>maximum number of different stocks in the wallet</dd>
<dt><strong><code>take_profit</code></strong> :&ensp;<code>float</code></dt>
<dd>if the price of a stock increases by this fraction, it will be sold;
if equal 0 - take profit is deactivated (default)</dd>
<dt><strong><code>stop_loss</code></strong> :&ensp;<code>float</code></dt>
<dd>if the price of a stock decreases by this fraction (comparing to the
purchase price), it will be sold;
if equal 0 - stop loss is deactivated (default)</dd>
<dt><strong><code>auto_trading</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True selling immediately when stop loss / take profit is reached is
simulated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>decorator that returns pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulator(time_range: pd.DatetimeIndex,
              traded_stocks: dict, 
              wallet: Wallet, 
              max_positions: int = 5, 
              take_profit: float = 0.0, 
              stop_loss: float = 0.0, 
              auto_trading: bool = False):
    &#34;&#34;&#34;
    This function returns decorator for a stock market strategy, that returns 
    change of wallet value over given time_range (in pandas.DataFrame)

    Parameters
    ----------
    time_range : pandas.DatetimeIndex
        an array with trading days only (no Saturdays, Sundays, holidays)
    traded_stocks : dict
        a dictionary with stocks.stock.Stock instances
    wallet : marketools.Wallet
        Wallet for trading 
    max_positions : int 
        maximum number of different stocks in the wallet
    take_profit : float
        if the price of a stock increases by this fraction, it will be sold;
        if equal 0 - take profit is deactivated (default)
    stop_loss : float
        if the price of a stock decreases by this fraction (comparing to the 
        purchase price), it will be sold; 
        if equal 0 - stop loss is deactivated (default)
    auto_trading : boolean
        if True selling immediately when stop loss / take profit is reached is 
        simulated

    Returns
    -------
    decorator that returns pandas.DataFrame
    &#34;&#34;&#34;

    warnings.warn(&#34;deprecated, consider using Simulator class instead&#34;,
                  DeprecationWarning)

    def strategy_wrapper(func):

        def simulation(*args, **kwargs):
            wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])
            stocks_to_buy = []
            stocks_to_sell = []

            for day in time_range:
                day_str = day.strftime(&#39;%Y-%m-%d&#39;)

                # Buy selected day before. Loop over list, order can be important here.
                # Strategy can sort relevant stocks - high priority first.
                for tck in stocks_to_buy:
                    if not wallet.get_volume_of_stocks(tck):
                        price = traded_stocks[tck].ohlc[&#39;Open&#39;].get(day, None)
                        if price:
                            total = calculate_investment_value(wallet, max_positions)
                            total = total - wallet(total)  # needs some money to pay commission
                            volume = math.floor(total/price)
                            if volume &gt; 0:
                                wallet.buy(tck, volume, price)
                                print(info_str(day_str, &#39;B&#39;, tck, volume, price))
                                # make sure to not sell it the same day
                                if tck in stocks_to_sell:
                                    stocks_to_sell.remove(tck)

                # Sell selected day before. List to set, we dont care here about the order.
                # Set will remove duplicates.
                for tck in set(stocks_to_sell):
                    if wallet.get_volume_of_stocks(tck):
                        price = traded_stocks[tck].ohlc[&#39;Open&#39;].get(day, None)
                        if price: 
                            print_color = determine_print_color_from_prices(price, wallet.get_purchase_price_of_stocks(tck))
                            volume = wallet.sell_all(tck, price)
                            print_color(info_str(day_str, &#39;S&#39;, tck, volume, price))

                # call decorated function - strategy function
                stocks_to_buy, stocks_to_sell = func(day=day, traded_stocks=traded_stocks, *args, **kwargs)

                # if auto trading is active, check if price of any stock in the wallet crossed
                # take proffit or stop loss price; if yes then sell it immediately 
                if auto_trading:
                    for tck in wallet.list_stocks().copy():

                        price_max = traded_stocks[tck].ohlc[&#39;High&#39;].get(day, None)
                        if price:
                            wallet.update_price(tck, price_max)
                        if wallet.change(tck) &gt; take_profit:
                            price = wallet.get_purchase_price_of_stocks(tck) * (1+take_profit)  # selling it immediately
                            price = round(price, 2)
                            volume = wallet.sell_all(tck, price)
                            print_green(info_str(day_str, &#39;TP&#39;, tck, volume, price))
                            continue

                        price_min = traded_stocks[tck].ohlc[&#39;Low&#39;].get(day, None)
                        if price:
                            wallet.update_price(tck, price_min)
                        if wallet.change(tck) &lt; -stop_loss:
                            price = wallet.get_purchase_price_of_stocks(tck) * (1-stop_loss)  # selling it immediately
                            price = round(price, 2)
                            volume = wallet.sell_all(tck, price)
                            print_red(info_str(day_str, &#39;SL&#39;, tck, volume, price))
                            
                for tck in wallet.list_stocks():                        
                    # update the price to the closing price and calculate relative price change
                    ohlc = traded_stocks[tck].ohlc
                    price = ohlc[&#39;Close&#39;].get(day, None)
                    if price:
                        wallet.update_price(tck, price)

                    # if auto trading is not active, then take profit / stop loss the next day
                    if not auto_trading:

                        # take profit the next day
                        if take_profit and wallet.change(tck) &gt; take_profit:
                            stocks_to_sell.append(tck)

                        # stop loss the next day - price below purchase price
                        if stop_loss and wallet.change(tck) &lt; -stop_loss:
                            stocks_to_sell.append(tck)

                # save history of the wallet
                wallet_history = wallet_history.append(
                    {&#39;Date&#39;: day, &#39;Wallet state&#39;: wallet.total_value},
                    ignore_index=True
                    )
            
            return wallet_history

        return simulation

    return strategy_wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="marketools.simulator.Simulator"><code class="flex name class">
<span>class <span class="ident">Simulator</span></span>
<span>(</span><span>time_range: pandas.core.indexes.datetimes.DatetimeIndex, traded_stocks_data: dict, wallet: marketools.wallet.Wallet, max_positions: int = 5, take_profit: float = 0.0, stop_loss: float = 0.0, live_trading: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulator for stock market strategies.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>time_range</code></strong> :&ensp;<code>pandas.DatetimeIndex</code></dt>
<dd>an array with trading days only (no Saturdays, Sundays, holidays)</dd>
<dt><strong><code>traded_stocks_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>a dictionary with stocks.stock.Stock instances</dd>
<dt><strong><code>wallet</code></strong> :&ensp;<code>marketools.Wallet</code></dt>
<dd>Wallet for trading</dd>
<dt><strong><code>max_positions</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum number of different stocks in the wallet</dd>
<dt><strong><code>take_profit</code></strong> :&ensp;<code>float</code></dt>
<dd>if the price of a stock increases by this fraction, it will be sold;
if equal 0 - take profit is deactivated (default)</dd>
<dt><strong><code>stop_loss</code></strong> :&ensp;<code>float</code></dt>
<dd>if the price of a stock decreases by this fraction (comparing to the
purchase price), it will be sold;
if equal 0 - stop loss is deactivated (default)</dd>
<dt><strong><code>live_trading</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True selling immediately when stop loss / take profit is reached is
simulated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Simulator:
    &#34;&#34;&#34;
    Simulator for stock market strategies.

    Attributes
    ----------
    time_range : pandas.DatetimeIndex
        an array with trading days only (no Saturdays, Sundays, holidays)
    traded_stocks_data : dict
        a dictionary with stocks.stock.Stock instances
    wallet : marketools.Wallet
        Wallet for trading
    max_positions : int
        maximum number of different stocks in the wallet
    take_profit : float
        if the price of a stock increases by this fraction, it will be sold;
        if equal 0 - take profit is deactivated (default)
    stop_loss : float
        if the price of a stock decreases by this fraction (comparing to the
        purchase price), it will be sold;
        if equal 0 - stop loss is deactivated (default)
    live_trading : boolean
        if True selling immediately when stop loss / take profit is reached is
        simulated
    &#34;&#34;&#34;

    def __init__(self, time_range: pd.DatetimeIndex, traded_stocks_data: dict,
                 wallet: Wallet, max_positions: int = 5,
                 take_profit: float = 0.0, stop_loss: float = 0.0,
                 live_trading: bool = False):

        self.time_range = time_range
        self.traded_stocks_data = traded_stocks_data
        self.wallet = wallet
        self.wallet_init_value = wallet.total_value
        self.max_positions = max_positions
        self.take_profit = take_profit
        self.stop_loss = stop_loss
        self.live_trading = live_trading
        self.wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])

    def reset(self) -&gt; None:
        &#34;&#34;&#34;
        Resets the value of wallet to initial value, and removes all stocks from
        the wallet and its history.
        &#34;&#34;&#34;
        self.wallet = Wallet(self.wallet.rate, self.wallet.minimum)
        self.wallet.money = self.wallet_init_value
        self.wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])

    def run(self, strategy_function, *args, **kwargs) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        Runs the simulation for given strategy and returns DataFrame with
        wallet value for each day in given time range.

        Parameters
        ----------
        strategy_function : func
            Function with investment strategy. Must take dictionary with traded
            stocks data (self.traded_stocks_data) and date as inputs. Must
            return set of lists (stocks_to_buy, stocks_to_sell).
        kwargs
            Other inputs to investment strategy (strategy_function).

        Returns
        -------
        pandas.DataFrame
        &#34;&#34;&#34;

        stocks_to_buy = []
        stocks_to_sell = []

        for day in self.time_range:
            day_str = day.strftime(&#39;%Y-%m-%d&#39;)

            # Buy selected day before. Loop over list, order can be important
            # here. Strategy can sort relevant stocks - high priority first.
            for tck in stocks_to_buy:

                if not self.wallet.get_volume_of_stocks(tck):
                    price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                        .get(day, None)

                    if price:
                        total = calculate_investment_value(
                            self.wallet, self.max_positions)

                        # needs some money to pay commission
                        total = total - self.wallet.commission(total)
                        volume = math.floor(total / price)

                        if volume &gt; 0:
                            self.wallet.buy(tck, volume, price)
                            print(info_str(day_str, &#39;B&#39;, tck, volume, price))
                            # make sure to not sell it the same day

                            if tck in stocks_to_sell:
                                stocks_to_sell.remove(tck)

            # Sell selected day before. List to set, we don&#39;t care here about
            # the order. Set will remove duplicates.
            for tck in set(stocks_to_sell):

                if self.wallet.get_volume_of_stocks(tck):
                    price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                        .get(day, None)

                    if price:
                        print_color = determine_print_color_from_prices(
                            price,
                            self.wallet.get_purchase_price_of_stocks(tck))
                        volume = self.wallet.sell_all(tck, price)
                        print_color(info_str(day_str, &#39;S&#39;, tck, volume, price))

            # call decorated function - strategy function
            stocks_to_buy, stocks_to_sell = strategy_function(
                day=day, traded_stocks=self.traded_stocks_data, *args, **kwargs)

            # if auto trading is active, check if price of any stock in the
            # wallet crossed take profit or stop loss price; if yes then sell it
            # immediately
            if self.live_trading:

                for tck in self.wallet.list_stocks().copy():
                    price_max = self.traded_stocks_data[tck].ohlc[&#39;High&#39;]\
                        .get(day, None)

                    if price_max:
                        self.wallet.update_price(tck, price_max)

                    if self.wallet.change(tck) &gt; self.take_profit:
                        # selling it immediately
                        price = self.wallet.get_purchase_price_of_stocks(tck)\
                                * (1 + self.take_profit)
                        price = round(price, 2)
                        volume = self.wallet.sell_all(tck, price)
                        print_green(info_str(day_str, &#39;TP&#39;, tck, volume, price))
                        continue

                    price_min = self.traded_stocks_data[tck].ohlc[&#39;Low&#39;]\
                        .get(day, None)

                    if price_min:
                        self.wallet.update_price(tck, price_min)

                    if self.wallet.change(tck) &lt; -self.stop_loss:
                        # selling it immediately
                        price = self.wallet.get_purchase_price_of_stocks(tck)\
                                * (1 - self.stop_loss)
                        price = round(price, 2)
                        volume = self.wallet.sell_all(tck, price)
                        print_red(info_str(day_str, &#39;SL&#39;, tck, volume, price))

            for tck in self.wallet.list_stocks():
                # update the price to the closing price
                ohlc = self.traded_stocks_data[tck].ohlc
                price = ohlc[&#39;Close&#39;].get(day, None)

                if price:
                    self.wallet.update_price(tck, price)

                # if auto trading is not active, then take profit / stop loss
                # the next day
                if not self.live_trading:

                    # take profit the next day
                    if (self.take_profit &gt; 0) \
                            and (self.wallet.change(tck) &gt; self.take_profit):
                        stocks_to_sell.append(tck)

                    # stop loss the next day - price below purchase price
                    if (self.stop_loss &gt; 0)\
                            and (self.wallet.change(tck) &lt; -self.stop_loss):
                        stocks_to_sell.append(tck)

            # save history of the wallet
            self.wallet_history = self.wallet_history.append(
                {&#39;Date&#39;: day, &#39;Wallet state&#39;: self.wallet.total_value},
                ignore_index=True)

        return self.wallet_history</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="marketools.simulator.Simulator.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the value of wallet to initial value, and removes all stocks from
the wallet and its history.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;
    Resets the value of wallet to initial value, and removes all stocks from
    the wallet and its history.
    &#34;&#34;&#34;
    self.wallet = Wallet(self.wallet.rate, self.wallet.minimum)
    self.wallet.money = self.wallet_init_value
    self.wallet_history = pd.DataFrame(columns=[&#39;Date&#39;, &#39;Wallet state&#39;])</code></pre>
</details>
</dd>
<dt id="marketools.simulator.Simulator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, strategy_function, *args, **kwargs) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the simulation for given strategy and returns DataFrame with
wallet value for each day in given time range.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>strategy_function</code></strong> :&ensp;<code>func</code></dt>
<dd>Function with investment strategy. Must take dictionary with traded
stocks data (self.traded_stocks_data) and date as inputs. Must
return set of lists (stocks_to_buy, stocks_to_sell).</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Other inputs to investment strategy (strategy_function).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, strategy_function, *args, **kwargs) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Runs the simulation for given strategy and returns DataFrame with
    wallet value for each day in given time range.

    Parameters
    ----------
    strategy_function : func
        Function with investment strategy. Must take dictionary with traded
        stocks data (self.traded_stocks_data) and date as inputs. Must
        return set of lists (stocks_to_buy, stocks_to_sell).
    kwargs
        Other inputs to investment strategy (strategy_function).

    Returns
    -------
    pandas.DataFrame
    &#34;&#34;&#34;

    stocks_to_buy = []
    stocks_to_sell = []

    for day in self.time_range:
        day_str = day.strftime(&#39;%Y-%m-%d&#39;)

        # Buy selected day before. Loop over list, order can be important
        # here. Strategy can sort relevant stocks - high priority first.
        for tck in stocks_to_buy:

            if not self.wallet.get_volume_of_stocks(tck):
                price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                    .get(day, None)

                if price:
                    total = calculate_investment_value(
                        self.wallet, self.max_positions)

                    # needs some money to pay commission
                    total = total - self.wallet.commission(total)
                    volume = math.floor(total / price)

                    if volume &gt; 0:
                        self.wallet.buy(tck, volume, price)
                        print(info_str(day_str, &#39;B&#39;, tck, volume, price))
                        # make sure to not sell it the same day

                        if tck in stocks_to_sell:
                            stocks_to_sell.remove(tck)

        # Sell selected day before. List to set, we don&#39;t care here about
        # the order. Set will remove duplicates.
        for tck in set(stocks_to_sell):

            if self.wallet.get_volume_of_stocks(tck):
                price = self.traded_stocks_data[tck].ohlc[&#39;Open&#39;]\
                    .get(day, None)

                if price:
                    print_color = determine_print_color_from_prices(
                        price,
                        self.wallet.get_purchase_price_of_stocks(tck))
                    volume = self.wallet.sell_all(tck, price)
                    print_color(info_str(day_str, &#39;S&#39;, tck, volume, price))

        # call decorated function - strategy function
        stocks_to_buy, stocks_to_sell = strategy_function(
            day=day, traded_stocks=self.traded_stocks_data, *args, **kwargs)

        # if auto trading is active, check if price of any stock in the
        # wallet crossed take profit or stop loss price; if yes then sell it
        # immediately
        if self.live_trading:

            for tck in self.wallet.list_stocks().copy():
                price_max = self.traded_stocks_data[tck].ohlc[&#39;High&#39;]\
                    .get(day, None)

                if price_max:
                    self.wallet.update_price(tck, price_max)

                if self.wallet.change(tck) &gt; self.take_profit:
                    # selling it immediately
                    price = self.wallet.get_purchase_price_of_stocks(tck)\
                            * (1 + self.take_profit)
                    price = round(price, 2)
                    volume = self.wallet.sell_all(tck, price)
                    print_green(info_str(day_str, &#39;TP&#39;, tck, volume, price))
                    continue

                price_min = self.traded_stocks_data[tck].ohlc[&#39;Low&#39;]\
                    .get(day, None)

                if price_min:
                    self.wallet.update_price(tck, price_min)

                if self.wallet.change(tck) &lt; -self.stop_loss:
                    # selling it immediately
                    price = self.wallet.get_purchase_price_of_stocks(tck)\
                            * (1 - self.stop_loss)
                    price = round(price, 2)
                    volume = self.wallet.sell_all(tck, price)
                    print_red(info_str(day_str, &#39;SL&#39;, tck, volume, price))

        for tck in self.wallet.list_stocks():
            # update the price to the closing price
            ohlc = self.traded_stocks_data[tck].ohlc
            price = ohlc[&#39;Close&#39;].get(day, None)

            if price:
                self.wallet.update_price(tck, price)

            # if auto trading is not active, then take profit / stop loss
            # the next day
            if not self.live_trading:

                # take profit the next day
                if (self.take_profit &gt; 0) \
                        and (self.wallet.change(tck) &gt; self.take_profit):
                    stocks_to_sell.append(tck)

                # stop loss the next day - price below purchase price
                if (self.stop_loss &gt; 0)\
                        and (self.wallet.change(tck) &lt; -self.stop_loss):
                    stocks_to_sell.append(tck)

        # save history of the wallet
        self.wallet_history = self.wallet_history.append(
            {&#39;Date&#39;: day, &#39;Wallet state&#39;: self.wallet.total_value},
            ignore_index=True)

    return self.wallet_history</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="marketools" href="index.html">marketools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="marketools.simulator.simulator" href="#marketools.simulator.simulator">simulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="marketools.simulator.Simulator" href="#marketools.simulator.Simulator">Simulator</a></code></h4>
<ul class="">
<li><code><a title="marketools.simulator.Simulator.reset" href="#marketools.simulator.Simulator.reset">reset</a></code></li>
<li><code><a title="marketools.simulator.Simulator.run" href="#marketools.simulator.Simulator.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>